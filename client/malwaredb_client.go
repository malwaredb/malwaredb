package main

import (
	"bufio"
	"bytes"
	sha2562 "crypto/sha256"
	"crypto/tls"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"github.com/malwaredb/malwaredb/mdbcommon"
	"golang.org/x/crypto/ssh/terminal"
	"io/ioutil"
	"os"
	"path/filepath"
	"strconv"
	"strings"
	"net/http"
	"syscall"
	"time"
)

func main() {
	fmt.Printf("MalwareDB client %s\n", mdbcommon.VERSION)

	if len(os.Args) < 2 {
		fmt.Fprintf(os.Stderr, "Available parameters:\n")
		fmt.Fprintf(os.Stderr, "\tConfig: Show client configuration.\n")
		fmt.Fprintf(os.Stderr, "\tInfo: Show server information.\n")
		fmt.Fprintf(os.Stderr, "\tLogin: Obtain an API key with your username and password.\n")
		fmt.Fprintf(os.Stderr, "\tSearch: Search known files based on provided file.\n")
		fmt.Fprintf(os.Stderr, "\t\tExample: %s Search <File1> <SimilarityThreshold>\n", os.Args[0])
		fmt.Fprintf(os.Stderr, "\tFetch: Download a sample by hash (MD5, SHA1, SHA256, or SHA512).\n")
		fmt.Fprintf(os.Stdout, "\tSources: List Sources, which are needed when uploading a sample.\n")
		fmt.Fprintf(os.Stderr, "\tUpload: Upload one or more files to MalwareDB.\n")
		fmt.Fprintf(os.Stderr, "\t\tExample: %s Upload <SourceNameOrID> <File1> [File2]...\n", os.Args[0])
		os.Exit(100)
	}

	configFile, err := LoadConfig()
	if err != nil {
		fmt.Fprintf(os.Stderr, "Unable to find or load configuation file: %s\n", err)
		configPath, err := CreateEmptyConfig()
		if err == nil {
			fmt.Fprintf(os.Stderr, "Created empty config file at %s.\n", configPath)
		}
		os.Exit(100)
	}

	switch strings.ToLower(os.Args[1]) {
		case "upload": uploadFile(configFile)
		case "info": showServerInfo(configFile)
		case "login": getAPIkey(configFile)
		case "search": searchBasedOnFile(configFile)
		case "fetch": fetchSampleByHash(configFile)
		case "config":
			fmt.Printf("Configured to connect to %s:%s.\n", configFile.ServerHost, configFile.ServerPort)
			if len(configFile.UserAPIKey) > 5 {
				fmt.Println("User API Key is set.")
			}
		case "sources": showSources(configFile)
		default: fmt.Fprintf(os.Stderr, "Unknown option %s.\n", os.Args[1])
	}
}

func uploadFile(config ClientConfigFile) {
	if len(os.Args) < 4 {
		fmt.Fprintf(os.Stderr, "No file(s) selected.\n")
		return
	}

	if len(config.UserAPIKey) < 5 {
		fmt.Fprintf(os.Stderr, "API too short.\n")
		return
	}

	var URL string = fmt.Sprintf("https://%s:%s%s", config.ServerHost, config.ServerPort, mdbcommon.UploadSampleURL)

	var netClient = &http.Client{
		Timeout: time.Second * 10,
	}
	var sourceName = strings.ToLower(os.Args[2])
	isSourceID := false
	sourceID64 := int64(-1)
	sourceID, err := strconv.Atoi(sourceName)
	if err == nil {
		isSourceID = true
		sourceID64 = int64(sourceID)
	}

	if !isSourceID {
		sourcesInfo, err := config.GetSources()
		if err != nil {
			fmt.Fprintf(os.Stderr, "Can't figure out source ID for %s.\n", sourceName)
			return
		}
		for _, sourceInfo := range sourcesInfo.Sources {
			if strings.ToLower(sourceInfo.Name) == sourceName {
				sourceID64 = sourceInfo.Id
				break
			}
		}
		if sourceID64 < 0 {
			fmt.Fprintf(os.Stderr, "Source %s doesn't exist.\n", sourceName)
			return
		}
	}

	for _, path := range os.Args[3:] {
		fileContents, err := ioutil.ReadFile(path)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Unable to read %s.\n", path)
			continue
		}

		var sample mdbcommon.NewSample
		sample.UserKey = config.UserAPIKey
		sample.SourceID = sourceID64
		sample.FileName = filepath.Base(path)
		sample.FileContentsBase64 = base64.StdEncoding.EncodeToString(fileContents)
		result, err := json.Marshal(sample)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Error marshalling for %s: %s.\n", path, err)
			continue
		}

		req, err := http.NewRequest("POST", URL, bytes.NewBuffer(result))
		if err != nil {
			fmt.Fprintf(os.Stderr, "Unable to upload file %s.\n", path)
			continue
		}
		req.Header.Set("Content-Type", "application/json")
		response, err := netClient.Do(req)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Error communicating with server: %s\n", err)
			continue
		}
		body, _ := ioutil.ReadAll(response.Body)
		fmt.Println(string(body))
	}
}

func getAPIkey(config ClientConfigFile) {
	reader := bufio.NewReader(os.Stdin)
	fmt.Print("Username: ")
	username, _ := reader.ReadString('\n')

	fmt.Print("Password: ")
	password, err := terminal.ReadPassword(int(syscall.Stdin))
	fmt.Println()
	if err != nil {
		fmt.Fprintf(os.Stderr, "Failed to read password.\n")
		os.Exit(100)
	}

	apiKeyRequest := mdbcommon.GetSetAPIKey{
		UserName:     username,
		UserPassword: string(password),
	}

	result, err := json.Marshal(apiKeyRequest)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Failed to build APIKey request: %v.\n", err)
		return
	}

	req, err := http.NewRequest("POST", config.HostURL() + "v1/users/getkey", bytes.NewBuffer(result))
	req.Header.Set("Content-Type", "application/json")
	http.DefaultTransport.(*http.Transport).TLSClientConfig = &tls.Config{InsecureSkipVerify: true}
	client := &http.Client{}
	resp, err := client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()

	//fmt.Println("response Status:", resp.Status)
	//fmt.Println("response Headers:", resp.Header)
	body, _ := ioutil.ReadAll(resp.Body)
	//fmt.Println("response Body:", string(body))

	jsonParser := json.NewDecoder(bytes.NewReader(body))
	jsonParser.Decode(&apiKeyRequest)
	if len(apiKeyRequest.APIKey) > 10 {
		err = config.UpdateAPIKey(apiKeyRequest.APIKey)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Failed to update the API key in the config file: %v.", err)
		}
	} else {
		fmt.Fprintf(os.Stderr, "Response message: %s\n", apiKeyRequest.Message)
	}
}

func showServerInfo(config ClientConfigFile) {
	info, err := config.GetServerInfo()
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error getting info: %s\n", err)
	}
	fmt.Printf("MalwareDB v%s on %s %s\n", info.MDBVersion, info.OSName, info.GoVersion)
	fmt.Printf("Num Samples: %d\n", info.NumSamples)
	fmt.Printf("Database version: %s\n", info.DBVersion)
	fmt.Printf("Uptime: %s\n", info.Uptime)
	showSupportedFileTypes(config)
}

func showSupportedFileTypes(config ClientConfigFile) {
	types, err := config.GetSupportedFileTypes()
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error getting info: %s\n", err)
	}
	fmt.Printf("Number of supported file types: %d\n", types.NumFileTypes)
	for _, ftype := range types.FileTypes {
		executableStr := ""
		if ftype.TypeExecutable {
			executableStr = " (executable)"
		}
		fmt.Printf("%s%s: %s\n", ftype.TypeName, executableStr, ftype.Description)
	}
}

func showSources(config ClientConfigFile) {
	fSources, err := config.GetSources()
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error getting info: %s\n", err)
	}
	fmt.Printf("Number of file sources: %d\n", fSources.NumSources)
	for _, sourceInfo := range fSources.Sources {
		fmt.Printf("%d: %s: %s\n", sourceInfo.Id, sourceInfo.Name, sourceInfo.Description)
	}
}

func searchBasedOnFile(config ClientConfigFile) {
	if len(os.Args) < 3 {
		fmt.Fprintf(os.Stderr, "Expected usage: %s Search <FilePath> [Threshold]\n", os.Args[0])
		os.Exit(1)
	}
	fPath := os.Args[2]
	similarityThreshold := 10.0
	if len(os.Args) > 3 {
		simThreshTest, err := strconv.ParseFloat(os.Args[3], 64)
		if err == nil {
			if simThreshTest < 0 {
				simThreshTest *= -1
			}
			if simThreshTest < 1 {
				simThreshTest *= 100.0
			}
			similarityThreshold = simThreshTest
		} else {
			fmt.Printf("%s isn't a floating point number.\n", os.Args[3])
		}
	}
	fmt.Printf("Searching with similarity threshold of %.2f\n", similarityThreshold)

	fileContents, err := ioutil.ReadFile(fPath)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error reading %s: %s.\n", fPath, err)
		return
	}
	sha256 := fmt.Sprintf("%X", sha2562.Sum256(fileContents))
	searchResults, err := config.SearchBasedOnFile(fileContents, similarityThreshold)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error searching for %s: %s.\n", fPath, err)
		return
	}
	fmt.Printf("Found %d results.\n", searchResults.NumResults)
	for _, searchResultRow := range searchResults.FoundSamples {
		isExactMatch := sha256 == searchResultRow.SHA256
		exactMatchMsg := ""
		if isExactMatch {
			exactMatchMsg = "Exact Match: "
		}

		fmt.Printf("%s%s Similarity score: %f\n", exactMatchMsg, searchResultRow.SHA1, searchResultRow.SimilarityScore)
		for _, fileSource := range searchResultRow.Sources {
			fileNames := strings.Join(fileSource.FileNames, "")
			fmt.Printf("\t%s %s uploaded by %s\n", fileSource.SourceName, fileNames, fileSource.UploaderUname)
		}
	}
}

func fetchSampleByHash(config ClientConfigFile) {
	if len(os.Args) != 3 {
		fmt.Fprintf(os.Stderr, "Expected usage: %s Fetch <HashValue>\n", os.Args[0])
		os.Exit(1)
	}
	fileContents, err := config.GetFileBytes(os.Args[2])
	if err != nil {
		fmt.Fprintf(os.Stderr, "Unable to fetch file: %s.\n", err)
		os.Exit(1)
	}
	if len(fileContents) < 2 {
		fmt.Fprintf(os.Stderr, "Received empty filee.\n")
		os.Exit(1)
	}
	err = ioutil.WriteFile(os.Args[2], fileContents, 0777)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Failed to save sample: %s.\n", err)
		os.Exit(1)
	}
	fmt.Println("Sample saved.")
}