package main

import (
	"bufio"
	"bytes"
	"crypto/tls"
	"encoding/json"
	"fmt"
	"github.com/rjzak/MalwareDB/mdbcommon"
	"golang.org/x/crypto/ssh/terminal"
	"io/ioutil"
	"os"
	"strings"
	"net/http"
	"syscall"
	"time"
)

func main() {
	fmt.Printf("MalwareDB client %s\n", mdbcommon.VERSION)

	if len(os.Args) < 2 {
		fmt.Fprintf(os.Stderr, "Available parameters:\n")
		fmt.Fprintf(os.Stderr, "\tConfig: Show client configuration.\n")
		fmt.Fprintf(os.Stderr, "\tLogin: Obtain an API key with your username and password.\n")
		fmt.Fprintf(os.Stderr, "\tUpload: Upload one or more files to MalwareDB.\n")
		os.Exit(100)
	}

	configFile, err := LoadConfig()
	if err != nil {
		fmt.Fprintf(os.Stderr, "Unable to find or load configuation file: %s\n", err)
		configPath, err := CreateEmptyConfig()
		if err == nil {
			fmt.Fprintf(os.Stderr, "Created empty config file at %s.\n", configPath)
		}
		os.Exit(100)
	}

	switch strings.ToLower(os.Args[1]) {
		case "upload": uploadFile(configFile)
		case "login": getAPIkey(configFile)
		case "config": fmt.Printf("Configured to connect to %s:%s.\n", configFile.ServerHost, configFile.ServerPort)
		default: fmt.Fprintf(os.Stderr, "Unknown option %s.\n", os.Args[1])
	}
}

func uploadFile(config ClientConfigFile) bool {
	if len(os.Args) < 3 {
		fmt.Fprintf(os.Stderr, "No file(s) selected.\n")
		return false
	}

	var URL string = fmt.Sprintf("http://%s:%s/upload", config.ServerHost, config.ServerPort)

	var netClient = &http.Client{
		Timeout: time.Second * 10,
	}

	for _, path := range os.Args[2:] {
		file, err := os.Open(path)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Unable to open file %s.\n", path)
			panic(err)
		}
		defer file.Close()

		req, err := http.NewRequest("POST", URL, file)
		req.Header.Set("API-Key", config.UserAPIKey)
		req.Header.Set("Content-Type", "binary/octet-stream")
		req.Header.Set("MalwareDB-Version", mdbcommon.VERSION)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Unable to upload file %s.\n", path)
			panic(err)
		}
		netClient.Do(req)
	}

	return true
}

func getAPIkey(config ClientConfigFile) {
	reader := bufio.NewReader(os.Stdin)
	fmt.Print("Username: ")
	username, _ := reader.ReadString('\n')

	fmt.Print("Password: ")
	password, err := terminal.ReadPassword(int(syscall.Stdin))
	fmt.Println()
	if err != nil {
		fmt.Fprintf(os.Stderr, "Failed to read password.\n")
		os.Exit(100)
	}

	apiKeyRequest := mdbcommon.GetSetAPIKey{
		UserName:     username,
		UserPassword: string(password),
	}

	result, err := json.Marshal(apiKeyRequest)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Failed to build APIKey request: %v.\n", err)
		return
	}

	req, err := http.NewRequest("POST", config.HostURL() + "v1/users/getkey", bytes.NewBuffer(result))
	req.Header.Set("Content-Type", "application/json")
	http.DefaultTransport.(*http.Transport).TLSClientConfig = &tls.Config{InsecureSkipVerify: true}
	client := &http.Client{}
	resp, err := client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()

	fmt.Println("response Status:", resp.Status)
	fmt.Println("response Headers:", resp.Header)
	body, _ := ioutil.ReadAll(resp.Body)
	fmt.Println("response Body:", string(body))

	jsonParser := json.NewDecoder(bytes.NewReader(body))
	jsonParser.Decode(&apiKeyRequest)
	if len(apiKeyRequest.APIKey) > 10 {
		err = config.UpdateAPIKey(apiKeyRequest.APIKey)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Failed to update the API key in the config file: %v.", err)
		}
	} else {
		fmt.Fprintf(os.Stderr, "Response message: %s\n", apiKeyRequest.Message)
	}
}