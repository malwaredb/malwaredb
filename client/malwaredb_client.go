package main

import (
	"bufio"
	"bytes"
	"crypto/tls"
	"encoding/json"
	"fmt"
	"github.com/rjzak/MalwareDB/mdbcommon"
	"golang.org/x/crypto/ssh/terminal"
	"io/ioutil"
	"os"
	"strings"
	"net/http"
	"syscall"
	"time"
)

func main() {
	fmt.Printf("MalwareDB client %s\n", mdbcommon.VERSION)

	if len(os.Args) < 2 {
		fmt.Fprintf(os.Stderr, "Available parameters:\n")
		fmt.Fprintf(os.Stderr, "\tConfig: Show client configuration.\n")
		fmt.Fprintf(os.Stderr, "\tInfo: Show server information.\n")
		fmt.Fprintf(os.Stderr, "\tLogin: Obtain an API key with your username and password.\n")
		fmt.Fprintf(os.Stdout, "\tSources: List Sources, which are needed when uploading a sample.\n")
		fmt.Fprintf(os.Stderr, "\tUpload: Upload one or more files to MalwareDB.\n")
		os.Exit(100)
	}

	configFile, err := LoadConfig()
	if err != nil {
		fmt.Fprintf(os.Stderr, "Unable to find or load configuation file: %s\n", err)
		configPath, err := CreateEmptyConfig()
		if err == nil {
			fmt.Fprintf(os.Stderr, "Created empty config file at %s.\n", configPath)
		}
		os.Exit(100)
	}

	switch strings.ToLower(os.Args[1]) {
		case "upload": uploadFile(configFile)
		case "info": showServerInfo(configFile)
		case "login": getAPIkey(configFile)
		case "config": fmt.Printf("Configured to connect to %s:%s.\n", configFile.ServerHost, configFile.ServerPort)
		case "sources": showSources(configFile)
		default: fmt.Fprintf(os.Stderr, "Unknown option %s.\n", os.Args[1])
	}
}

func uploadFile(config ClientConfigFile) bool {
	if len(os.Args) < 3 {
		fmt.Fprintf(os.Stderr, "No file(s) selected.\n")
		return false
	}

	var URL string = fmt.Sprintf("http://%s:%s/upload", config.ServerHost, config.ServerPort)

	var netClient = &http.Client{
		Timeout: time.Second * 10,
	}

	for _, path := range os.Args[2:] {
		file, err := os.Open(path)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Unable to open file %s.\n", path)
			panic(err)
		}
		defer file.Close()

		req, err := http.NewRequest("POST", URL, file)
		req.Header.Set("API-Key", config.UserAPIKey)
		req.Header.Set("Content-Type", "binary/octet-stream")
		req.Header.Set("MalwareDB-Version", mdbcommon.VERSION)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Unable to upload file %s.\n", path)
			panic(err)
		}
		netClient.Do(req)
	}

	return true
}

func getAPIkey(config ClientConfigFile) {
	reader := bufio.NewReader(os.Stdin)
	fmt.Print("Username: ")
	username, _ := reader.ReadString('\n')

	fmt.Print("Password: ")
	password, err := terminal.ReadPassword(int(syscall.Stdin))
	fmt.Println()
	if err != nil {
		fmt.Fprintf(os.Stderr, "Failed to read password.\n")
		os.Exit(100)
	}

	apiKeyRequest := mdbcommon.GetSetAPIKey{
		UserName:     username,
		UserPassword: string(password),
	}

	result, err := json.Marshal(apiKeyRequest)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Failed to build APIKey request: %v.\n", err)
		return
	}

	req, err := http.NewRequest("POST", config.HostURL() + "v1/users/getkey", bytes.NewBuffer(result))
	req.Header.Set("Content-Type", "application/json")
	http.DefaultTransport.(*http.Transport).TLSClientConfig = &tls.Config{InsecureSkipVerify: true}
	client := &http.Client{}
	resp, err := client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()

	//fmt.Println("response Status:", resp.Status)
	//fmt.Println("response Headers:", resp.Header)
	body, _ := ioutil.ReadAll(resp.Body)
	//fmt.Println("response Body:", string(body))

	jsonParser := json.NewDecoder(bytes.NewReader(body))
	jsonParser.Decode(&apiKeyRequest)
	if len(apiKeyRequest.APIKey) > 10 {
		err = config.UpdateAPIKey(apiKeyRequest.APIKey)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Failed to update the API key in the config file: %v.", err)
		}
	} else {
		fmt.Fprintf(os.Stderr, "Response message: %s\n", apiKeyRequest.Message)
	}
}

func showServerInfo(config ClientConfigFile) {
	var URL string = fmt.Sprintf("https://%s:%s/%s", config.ServerHost, config.ServerPort, mdbcommon.GetServerInfoURL)
	http.DefaultTransport.(*http.Transport).TLSClientConfig = &tls.Config{InsecureSkipVerify: true}
	client := &http.Client{}
	req, err := http.NewRequest("GET", URL, bytes.NewBuffer([]byte{}))
	if err != nil {
		panic(err)
	}
	req.Header.Set("Content-Type", "application/json")
	resp, err := client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	body, _ := ioutil.ReadAll(resp.Body)
	//fmt.Println("response Body:", string(body))

	jsonParser := json.NewDecoder(bytes.NewReader(body))
	var info mdbcommon.ServerInfo
	err = jsonParser.Decode(&info)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error getting info: %s\n", err)
	}
	fmt.Printf("MalwareDB v%s on %s %s\n", info.MDBVersion, info.OSName, info.GoVersion)
	fmt.Printf("Num Samples: %d\n", info.NumSamples)
	fmt.Printf("Database version: %s\n", info.DBVersion)
	fmt.Printf("Uptime: %s\n", info.Uptime)
	showSupportedFileTypes(config)
}

func showSupportedFileTypes(config ClientConfigFile) {
	var URL string = fmt.Sprintf("https://%s:%s/%s", config.ServerHost, config.ServerPort, mdbcommon.GetServerSupportedFileTypes)
	http.DefaultTransport.(*http.Transport).TLSClientConfig = &tls.Config{InsecureSkipVerify: true}
	client := &http.Client{}
	req, err := http.NewRequest("GET", URL, bytes.NewBuffer([]byte{}))
	if err != nil {
		panic(err)
	}
	req.Header.Set("Content-Type", "application/json")
	resp, err := client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	body, _ := ioutil.ReadAll(resp.Body)
	//fmt.Println("response Body:", string(body))

	jsonParser := json.NewDecoder(bytes.NewReader(body))
	var types mdbcommon.ServerFileTypes
	err = jsonParser.Decode(&types)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error getting info: %s\n", err)
	}
	fmt.Printf("Number of supported file types: %d\n", types.NumFileTypes)
	for _, ftype := range types.FileTypes {
		executableStr := ""
		if ftype.TypeExecutable {
			executableStr = " (executable)"
		}
		fmt.Printf("%s%s: %s\n", ftype.TypeName, executableStr, ftype.Description)
	}
}

func showSources(config ClientConfigFile) {
	// be sure the server url is URL/PATH not URL//PATH, which turns POST to GET on the server side.
	var URL string = fmt.Sprintf("https://%s:%s%s", config.ServerHost, config.ServerPort, mdbcommon.GetFileSources)
	http.DefaultTransport.(*http.Transport).TLSClientConfig = &tls.Config{InsecureSkipVerify: true}
	var sourceRequest mdbcommon.GetSourcesRequest
	sourceRequest.ReleasableOnly = false
	sourceRequest.APIKey = config.UserAPIKey
	result, err := json.Marshal(sourceRequest)
	if err != nil {
		panic(err)
	}

	req, err := http.NewRequest("POST", URL, bytes.NewBuffer(result))
	if err != nil {
		panic(err)
	}
	req.Header.Set("Content-Type", "application/json")
	client := &http.Client{}
	resp, err := client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	body, _ := ioutil.ReadAll(resp.Body)
	//fmt.Println("response Body:", string(body))

	jsonParser := json.NewDecoder(bytes.NewReader(body))
	var fSources mdbcommon.Sources
	err = jsonParser.Decode(&fSources)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error getting info: %s\n", err)
	}
	fmt.Printf("Number of file sources: %d\n", fSources.NumSources)
	for _, sourceInfo := range fSources.Sources {
		fmt.Printf("%d: %s: %s\n", sourceInfo.Id, sourceInfo.Name, sourceInfo.Description)
	}
}