package main

import (
	"bytes"
	"crypto/rand"
	"io"
	"os"
	"fmt"
	"runtime"
	"github.com/rjzak/MalwareDB/mdbcommon"
	"net/http"
	"syscall"

	"golang.org/x/crypto/ssh/terminal"
	"golang.org/x/crypto/scrypt"
)

func main() {
	fmt.Printf("MalwareDB server %s\n", mdbcommon.VERSION)

	if len(os.Args) == 2 && os.Args[1] == "CreateConfig" {
		err := GenConfig(CONFIG_PATH)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Error creating config file %s: %v.\n", CONFIG_PATH, err)
		} else {
			fmt.Println("Config file created.")
		}
		os.Exit(0)
	}

	configFile, err := LoadConfig()
	if err != nil {
		fmt.Fprintf(os.Stderr, "Unable to find or load configuation file: %s\n", err)
		os.Exit(100)
	}

	if len(os.Args) == 2 && os.Args[1] == "ResetAdmin" {
		fmt.Print("Enter Password: ")
		password1, err := terminal.ReadPassword(int(syscall.Stdin))
		if err != nil {
			fmt.Fprintf(os.Stderr, "Failed to read password.\n")
			os.Exit(100)
		}

		fmt.Print("Re-Enter Password: ")
		password2, err := terminal.ReadPassword(int(syscall.Stdin))
		if err != nil {
			fmt.Fprintf(os.Stderr, "Failed to read password.\n")
			os.Exit(100)
		}

		if bytes.Compare(password1, password2) == 0 {
			salt := make([]byte, 128)
			_, err := io.ReadFull(rand.Reader, salt)
			if err != nil {
				fmt.Fprintf(os.Stderr, "Error generating salt: %v\n", err)
				os.Exit(100)
			}
			derivedKey, err := scrypt.Key(password1, salt, 32768, 8, 1, 32)
			if err != nil {
				fmt.Fprintf(os.Stderr, "Error generating key: %v\n", err)
				os.Exit(100)
			}
			sql := fmt.Sprintf("update person set password = '%s' where id = 0", string(derivedKey))
			err = configFile.dbDriver.RunQuery(sql)
			if err != nil {
				fmt.Fprintf(os.Stderr, "Error setting password: %v\n", err)
				os.Exit(100)
			} else {
				fmt.Println("Admin password set sucessfully.")
				os.Exit(0)
			}
		} else {
			fmt.Fprintf(os.Stderr, "Passwords did not match.\n")
			os.Exit(100)
		}
	}

	fmt.Printf("Number of Files: %d\n", configFile.dbDriver.NumFiles())
	fmt.Printf("Server listening on port %s.\n", configFile.Listen.Port)

	runtime.GOMAXPROCS(configFile.Listen.MaxThreads + 1) // Processing threads + main thread


	http.ListenAndServe(configFile.ListenString(), nil)

}
