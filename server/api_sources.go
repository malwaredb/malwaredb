package main

import (
	"database/sql"
	"encoding/json"
	"fmt"
	pg "github.com/lib/pq"
	"github.com/rjzak/MalwareDB/mdbcommon"
	"github.com/rjzak/MalwareDB/server/utils"
	"net/http"
	"os"
	"strings"
)

func GetSources(writer http.ResponseWriter, request *http.Request) {
	jsonParser := json.NewDecoder(request.Body)
	sourcesRequest := mdbcommon.GetSourcesRequest{}
	err := jsonParser.Decode(&sourcesRequest)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Unable to parse GetSourcesRequest: %s\n", err)
	}
	sourcesRequest.APIKey = strings.TrimSpace(sourcesRequest.APIKey)

	sourcesResponse := mdbcommon.Sources{}

	dbConn := utils.GetGlobalContext().ConfigFile.DbDriver
	sqlValidateUser := fmt.Sprintf("select id, uname from person where apikey = '%s'", sourcesRequest.APIKey)
	userID := -1
	uname := ""
	queryRow := dbConn.QueryRow(sqlValidateUser)
	err = queryRow.Scan(&userID, &uname)
	if err == sql.ErrNoRows {
		sourcesResponse.NumSources = -1
		sourcesResponse.ResponseMessage = "Invalid API key provided"
		result, _ := json.Marshal(sourcesResponse)
		writer.Write(result)
		return
	}

	sqlFindSources := "select id, name, description, url, firstacquisition, releasable from source"
	if sourcesRequest.ReleasableOnly {
		sqlFindSources += " where releasable is true"
	}

	sourceRows, err := dbConn.Query(sqlFindSources)
	if err != nil {
		sourcesResponse.NumSources = -1
		sourcesResponse.ResponseMessage = "DB connection issue"
		result, _ := json.Marshal(sourcesResponse)
		writer.Write(result)
		return
	}

	for sourceRows.Next() {
		srcInfo := mdbcommon.SourceInfo{}
		sourceAcq := pg.NullTime{}
		sourceRows.Scan(&srcInfo.Id, &srcInfo.Name, &srcInfo.Description, &srcInfo.URL, &sourceAcq, &srcInfo.IsReleasable)
		if sourceAcq.Valid {
			srcInfo.FirstAcquisition = sourceAcq.Time
		}
		sourcesResponse.NumSources += 1
		sourcesResponse.Sources = append(sourcesResponse.Sources, srcInfo)
	}
	result, _ := json.Marshal(sourcesResponse)
	writer.Write(result)
}