package main

import (
	"bufio"
	"bytes"
	"fmt"
	"github.com/rjzak/MalwareDB/mdbcommon"
	"github.com/rjzak/MalwareDB/server/fileprocessing"
	"github.com/rjzak/MalwareDB/server/utils"
	"io/ioutil"
	"os"
	"path/filepath"
	"strconv"
	"strings"
	"syscall"
	"golang.org/x/crypto/ssh/terminal"
)

const SERVICE_FILE = "/lib/systemd/system/malwaredb.service"

func CreateConfig() {
	err := utils.GenConfig(utils.CONFIG_PATH)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error creating config file %s: %v.\n", utils.CONFIG_PATH, err)
	} else {
		fmt.Println("Config file created.")
	}
	os.Exit(0)
}

func ResetAdminPassword(config *utils.ServerConfigFile) {
	fmt.Print("Enter Password: ")
	password1, err := terminal.ReadPassword(int(syscall.Stdin))
	if err != nil {
		fmt.Fprintf(os.Stderr, "Failed to read password.\n")
		os.Exit(100)
	}

	fmt.Print("\nRe-Enter Password: ")
	password2, err := terminal.ReadPassword(int(syscall.Stdin))
	if err != nil {
		fmt.Fprintf(os.Stderr, "Failed to read password.\n")
		os.Exit(100)
	}

	if bytes.Compare(password1, password2) == 0 {
		derivedKey, err := mdbcommon.PasswordToBytes(password1)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Error generating key: %v\n", err)
			os.Exit(100)
		}
		err = config.SetPassword(0, derivedKey)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Error setting password: %v\n", err)
			os.Exit(100)
		} else {
			fmt.Println("Admin password set successfully.")
			os.Exit(0)
		}
	} else {
		fmt.Fprintf(os.Stderr, "Passwords did not match.\n")
		os.Exit(100)
	}
}

func GetSelf() string {
	ex, _ := os.Executable()
	exPath, _ := filepath.Abs(ex)
	return exPath
}

func GetSelfDir() string {
	return filepath.Dir(GetSelf())
}

func InstallService() {
	var err error
	_, err = os.Stat(SERVICE_FILE)
	if !os.IsNotExist(err) {
		// If the service file exists, cancel.
		fmt.Fprintf(os.Stderr,"Systemd service file already exists, delete and retry. Path: %s", SERVICE_FILE)
	}

	systemDfile, err := os.Create(SERVICE_FILE)
	if err != nil {
		fmt.Fprintf(os.Stderr,"Unable to create file %s: %s", SERVICE_FILE, err)
		return
	}
	defer systemDfile.Close()

	systemDfile.WriteString("[Unit]\n")
	systemDfile.WriteString("Description=Malware Database\n")
	systemDfile.WriteString(fmt.Sprintf("ConditionPathExists=%s\n", GetSelf()))
	systemDfile.WriteString("After=network.target\n")

	systemDfile.WriteString("\n[Service]\n")
	systemDfile.WriteString("Type=simple\n")
	systemDfile.WriteString("User=nobody\n")

	systemDfile.WriteString("Restart=on-failure\n")
	systemDfile.WriteString("RestartSec=10\n")
	systemDfile.WriteString("startLimitIntervalSec=60\n")

	systemDfile.WriteString(fmt.Sprintf("WorkingDirectory=%s\n", GetSelfDir()))
	systemDfile.WriteString(fmt.Sprintf("ExecStart=%s\n", GetSelf()))

	systemDfile.WriteString("\n[Install]\n")
	systemDfile.WriteString("WantedBy=multi-user.target\n")

	return
}

func AddFileToDB(filePathString string) {
	fileContents, err := ioutil.ReadFile(filePathString)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Failed to read %s: %s\n.", filePathString, err)
		return
	}
	serverContext := utils.GetGlobalContext()

	fileTypeID, err := fileprocessing.FileTypeIDFromBytes(fileContents, serverContext.ConfigFile)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Failed to connect to DB: %s\n.", err)
		return
	}
	if fileTypeID < 0 {
		fmt.Fprintf(os.Stderr, "Failed to get fileTypeID\n.")
		return
	}
	fmt.Printf("%s: File Type: %d\n", filePathString, fileTypeID)

	sqlStatement := "select defaultFileSource from mdbconfig"
	row := serverContext.ConfigFile.DbDriver.QueryRow(sqlStatement)
	defaultSourceID := -9
	row.Scan(&defaultSourceID)

	if defaultSourceID < 0 {
		fmt.Fprintf(os.Stderr, "Default source ID not specified, not inserting.\n")
		return
	}

	fileprocessing.HandleFileSubmission(filepath.Base(filePathString), fileContents, fileTypeID, 0, defaultSourceID)
}

func FileSource(action string) {
	dbConn := utils.GetGlobalContext().ConfigFile.DbDriver
	if action == "list" {
		sqlStatement := "select defaultFileSource from mdbconfig"
		row := dbConn.QueryRow(sqlStatement)
		defaultID := -1
		row.Scan(&defaultID)

		sqlStatement = "select id, name, description, releasable from source"
		rows, err := dbConn.Query(sqlStatement)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Error getting sources: %s\n", err)
			return
		}
		defer rows.Close()
		sID := 0
		sName := ""
		sDesc := ""
		var sRel bool
		for rows.Next() {
			err = rows.Scan(&sID, &sName, &sDesc, &sRel)
			if err != nil {
				fmt.Fprintf(os.Stderr, "Error getting source info: %s\n", err)
				return
			}
			private := ""
			if !sRel {
				private = "Private"
			}
			defaultStr := ""
			if defaultID == sID {
				defaultStr = "Default"
			}
			label := ""
			if len(private) > 0 {
				label = private
			}
			if len(defaultStr) > 0 {
				if len(label) == 0 {
					label = defaultStr
				} else {
					label = fmt.Sprintf("%s, %s", label, defaultStr)
				}
			}
			if len(label) > 0 {
				label = fmt.Sprintf(" (%s)", label)
			}
			fmt.Printf("%s: %s%s\n", sName, sDesc, label)
		}
		return
	}
	if action == "add" {
		reader := bufio.NewReader(os.Stdin)
		fmt.Print("Source name: ")
		sourceName, err := reader.ReadString('\n')
		sourceName = strings.TrimSpace(sourceName)
		if err != nil {
			fmt.Printf("Input cancelled.")
			return
		}

		fmt.Print("Source description: ")
		sourceDesc, err := reader.ReadString('\n')
		sourceDesc = strings.TrimSpace(sourceDesc)
		if err != nil {
			fmt.Printf("Input cancelled.")
			return
		}

		fmt.Print("Source first acquisition date YYYY-MM-DD HH:MM:SS: ")
		sourceAcq, err := reader.ReadString('\n')
		sourceAcq = strings.TrimSpace(sourceAcq)
		if err != nil {
			fmt.Printf("Input cancelled.")
			return
		}

		fmt.Print("Source is shareable or releasable (true/false, yes/no): ")
		sourceRel, err := reader.ReadString('\n')
		if err != nil {
			fmt.Printf("Input cancelled.")
			return
		}
		sourceRel = strings.TrimSpace(strings.ToLower(sourceRel))
		if strings.Compare(sourceRel, "no") != 0 && strings.Compare(sourceRel, "yes") != 0 && strings.Compare(sourceRel, "true") != 0 && strings.Compare(sourceRel, "false") != 0 {
			fmt.Printf("Shareable/releasable input of %s is not acceptable.\n", sourceRel)
			return
		}

		sourceRelBool := false
		if strings.Compare(sourceRel, "yes") == 0 || strings.Compare(sourceRel, "true") == 0 {
			sourceRelBool = true
		}

		fmt.Println("Everything correct?")
		fmt.Printf("Name: %s\n", sourceName)
		fmt.Printf("Description: %s\n", sourceDesc)
		fmt.Printf("Date: %s\n", sourceAcq)
		fmt.Printf("Shareable/releasable: %v\n", sourceRelBool)
		fmt.Println("Press Ctrl-C now to abort, Enter to continue.")
		reader.ReadString('\n')

		sqlStatement := fmt.Sprintf("insert into source(name, description, firstacquisition, releasable) values('%s', '%s', '%s', %v)", sourceName, sourceDesc, sourceAcq, sourceRelBool)
		_, err = dbConn.Exec(sqlStatement)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Error inserting new file source: %v.\n", err)
			fmt.Fprintf(os.Stderr, "Query: %s\n", sqlStatement)
			return
		}
	}
	if action == "default" {
		sqlStatement := "select defaultFileSource from mdbconfig"
		row := dbConn.QueryRow(sqlStatement)
		defaultID := -1
		row.Scan(&defaultID)

		sqlStatement = "select id, name, description, releasable from source"
		rows, err := dbConn.Query(sqlStatement)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Error getting sources: %s\n", err)
			return
		}
		defer rows.Close()
		sID := 0
		sName := ""
		sDesc := ""
		var sRel bool
		for rows.Next() {
			err = rows.Scan(&sID, &sName, &sDesc, &sRel)
			if err != nil {
				fmt.Fprintf(os.Stderr, "Error getting source info: %s\n", err)
				return
			}
			private := ""
			if !sRel {
				private = " (Private)"
			}
			label := ""
			if len(private) > 0 {
				label = private
			}
			defaultStr := ""
			if defaultID == sID {
				defaultStr = "Current Default"
			}
			if len(defaultStr) > 0 {
				if len(label) == 0 {
					label = defaultStr
				} else {
					label = fmt.Sprintf("%s, %s", label, defaultStr)
				}
			}
			if len(label) > 0 {
				label = fmt.Sprintf(" (%s)", label)
			}
			fmt.Printf("%d: %s: %s%s\n", sID, sName, sDesc, label)
		}
		reader := bufio.NewReader(os.Stdin)
		fmt.Print("Pick an ID: ")
		requestedIDstr, err := reader.ReadString('\n')
		requestedIDstr = strings.TrimSpace(strings.ToLower(requestedIDstr))
		requestedIDint, err := strconv.Atoi(requestedIDstr)
		if err != nil {
			fmt.Fprintf(os.Stderr, "ID %s is not acceptable.\n", requestedIDstr)
			return
		}

		sqlStatement = fmt.Sprintf("update mdbconfig set defaultFileSource = %d", requestedIDint)
		_, err = dbConn.Exec(sqlStatement)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Error setting default file source: %v.\n", err)
		}
		return
	}
}