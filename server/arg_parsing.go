package main

import (
	"bytes"
	"fmt"
	"github.com/rjzak/MalwareDB/mdbcommon"
	"github.com/rjzak/MalwareDB/server/fileprocessing"
	"github.com/rjzak/MalwareDB/server/utils"
	"io/ioutil"
	"os"
	"path/filepath"
	"syscall"
	"golang.org/x/crypto/ssh/terminal"
)

const SERVICE_FILE = "/lib/systemd/system/malwaredb.service"

func CreateConfig() {
	err := utils.GenConfig(utils.CONFIG_PATH)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error creating config file %s: %v.\n", utils.CONFIG_PATH, err)
	} else {
		fmt.Println("Config file created.")
	}
	os.Exit(0)
}

func ResetAdminPassword(config *utils.ServerConfigFile) {
	fmt.Print("Enter Password: ")
	password1, err := terminal.ReadPassword(int(syscall.Stdin))
	if err != nil {
		fmt.Fprintf(os.Stderr, "Failed to read password.\n")
		os.Exit(100)
	}

	fmt.Print("\nRe-Enter Password: ")
	password2, err := terminal.ReadPassword(int(syscall.Stdin))
	if err != nil {
		fmt.Fprintf(os.Stderr, "Failed to read password.\n")
		os.Exit(100)
	}

	if bytes.Compare(password1, password2) == 0 {
		derivedKey, err := mdbcommon.PasswordToBytes(password1)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Error generating key: %v\n", err)
			os.Exit(100)
		}
		err = config.DbDriver.SetPassword(0, derivedKey)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Error setting password: %v\n", err)
			os.Exit(100)
		} else {
			fmt.Println("Admin password set successfully.")
			os.Exit(0)
		}
	} else {
		fmt.Fprintf(os.Stderr, "Passwords did not match.\n")
		os.Exit(100)
	}
}

func GetSelf() string {
	ex, _ := os.Executable()
	exPath, _ := filepath.Abs(ex)
	return exPath
}

func GetSelfDir() string {
	return filepath.Dir(GetSelf())
}

func InstallService() {
	var err error
	_, err = os.Stat(SERVICE_FILE)
	if !os.IsNotExist(err) {
		// If the service file exists, cancel.
		fmt.Fprintf(os.Stderr,"Systemd service file already exists, delete and retry. Path: %s", SERVICE_FILE)
	}

	systemDfile, err := os.Create(SERVICE_FILE)
	if err != nil {
		fmt.Fprintf(os.Stderr,"Unable to create file %s: %s", SERVICE_FILE, err)
		return
	}
	defer systemDfile.Close()

	systemDfile.WriteString("[Unit]\n")
	systemDfile.WriteString("Description=Malware Database\n")
	systemDfile.WriteString(fmt.Sprintf("ConditionPathExists=%s\n", GetSelf()))
	systemDfile.WriteString("After=network.target\n")

	systemDfile.WriteString("\n[Service]\n")
	systemDfile.WriteString("Type=simple\n")
	systemDfile.WriteString("User=nobody\n")

	systemDfile.WriteString("Restart=on-failure\n")
	systemDfile.WriteString("RestartSec=10\n")
	systemDfile.WriteString("startLimitIntervalSec=60\n")

	systemDfile.WriteString(fmt.Sprintf("WorkingDirectory=%s\n", GetSelfDir()))
	systemDfile.WriteString(fmt.Sprintf("ExecStart=%s\n", GetSelf()))

	systemDfile.WriteString("\n[Install]\n")
	systemDfile.WriteString("WantedBy=multi-user.target\n")

	return
}

func AddFileToDB(filePathString string) {
	fileContents, err := ioutil.ReadFile(filePathString)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Failed to read %s: %s\n.", filePathString, err)
		return
	}
	serverContext := utils.GetGlobalContext()

	fileTypeID, err := fileprocessing.FileTypeIDFromBytes(fileContents, serverContext.ConfigFile)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Failed to connect to DB: %s\n.", err)
		return
	}

	sqlStatement := "select defaultFileSource from mdbconfig"
	row := serverContext.ConfigFile.DbDriver.QueryRow(sqlStatement)
	defaultSourceID := -9
	row.Scan(&defaultSourceID)

	if defaultSourceID < 0 {
		fmt.Fprintf(os.Stderr, "Default source ID not specified, not inserting.\n")
		return
	}

	fileprocessing.HandleFileSubmission(filepath.Base(filePathString), fileContents, fileTypeID, 0, defaultSourceID)
}