package fileprocessing

import (
	"database/sql"
	"fmt"
	"bytes"
	"github.com/rjzak/MalwareDB/mdbcommon"
	"github.com/rjzak/MalwareDB/server/utils"
	"os"
	"strings"
	pg "github.com/lib/pq"
)

func FileTypeIDFromBytes(fileContents []byte, config *utils.ServerConfigFile) (int, error) {
	rows, err := config.DbDriver.Query("select id, magic, name from filetype")
	if err != nil {
		return -1, err
	}

	var fileTypeID int = -1
	var fileTypeName = ""
	var magic pg.ByteaArray
	var matched = false
	for rows.Next() {
		err = rows.Scan(&fileTypeID, &magic, &fileTypeName)
		if err != nil {
			rows.Close()
			return -1, err
		}

		for _, magicNum := range magic {
			//fmt.Printf("Testing: %v : %s.\n", magicNum, fileTypeName)
			if bytes.HasPrefix(fileContents, magicNum) {
				fmt.Printf("Matched to %s.\n", fileTypeName)
				matched = true
				break
			}
		}
	}
	rows.Close()
	if matched {
		return fileTypeID, nil
	}
	return -1, nil
}

func HandleFileSubmission(fileName string, fileContents []byte, fileType int, userID int, sourceID int) {
	var err error
	context := utils.GetGlobalContext()
	context.GlobalWaitGroup.Add(1)
	defer context.GlobalWaitGroup.Done()

	fileHashes := mdbcommon.GetFileHashesFromBytes(fileContents)
	fmt.Println("Calculated hashes")
	sqlStatement := fmt.Sprintf("select id from file where sha256 = '%s'", fileHashes.SHA256)
	row := context.ConfigFile.DbDriver.QueryRow(sqlStatement)

	fileID := int64(-9)
	err = row.Scan(&fileID)
	fmt.Printf("FileID: %d\n", fileID)
	fmt.Printf("SHA-256: %s\n", fileHashes.SHA256)
	fileNames := make([]string, 0)

	if err == sql.ErrNoRows {
		// Add this new file to the database
		fmt.Println("File not seen previously, inserting into DB")
		fileEntropy := Entropy(fileContents)
		fmt.Printf("Entropy: %1.4f\n", fileEntropy)
		sqlStatement = fmt.Sprintf("insert into file(sha1, sha256, sha512, md5, lzjd, ssdeep, filetypeid, size, entropy) values ('%s', '%s', '%s', '%s', '%s', '%s', %d, %d, %f)", fileHashes.SHA1, fileHashes.SHA256, fileHashes.SHA512, fileHashes.MD5, fileHashes.LZJD, fileHashes.SSDeep, fileType, len(fileContents), fileEntropy)
		_, err = context.ConfigFile.DbDriver.Exec(sqlStatement)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Failed to insert new file record: %v\n", err)
			fmt.Fprintf(os.Stderr, "SQL: %s\n", sqlStatement)
			return
		}
		fmt.Println("File inserted into file table.")
		sqlStatement = fmt.Sprintf("select id from file where sha256 = '%s'", fileHashes.SHA256)
		row = context.ConfigFile.DbDriver.QueryRow(sqlStatement)
		if row.Scan(&fileID) == sql.ErrNoRows {
			fmt.Fprintf(os.Stderr, "Failed to get file id from newly-inserted new file record: %v\n", err)
			return
		}
		fmt.Printf("File has an ID: %d\n", fileID)
		sqlStatement = fmt.Sprintf("insert into filesource(fileid, sourceid, userid, filename, firstseen) values(%d, %d, %d, ARRAY['%s'], CURRENT_TIMESTAMP)", fileID, sourceID, userID, fileName)
		_, err = context.ConfigFile.DbDriver.Exec(sqlStatement)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Failed to set relationship between fileid %d and sourceid %d for newly-uploaded file: %v\n", fileID, sourceID, err)
			fmt.Fprintf(os.Stderr, "SQL: %s\n", sqlStatement)
		}
		fPath := HashToPath(fileHashes.SHA256)
		fileObj, err := os.Create(fPath)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Error creating file %s: %s.\n", fPath, err)
		} else {
			defer fileObj.Close()
			fileObj.Write(fileContents)
			fmt.Println("Saved file contents to local dir.")
		}
	} else {
		// File has already been seen
		sqlStatement = fmt.Sprintf("select filename from filesource where fileid = %d and sourceid = %d", fileID, sourceID)
		row := context.ConfigFile.DbDriver.QueryRow(sqlStatement)
		if row.Scan(&fileNames) == sql.ErrNoRows {
			// First time seeing this file from this source
			sqlStatement = fmt.Sprintf("insert into filsource(fileid, sourceid, filename, firstseen) values(%d, %d, {'%s'}, CURRENT_TIMESTAMP", fileID, sourceID, fileName)
			_, err = context.ConfigFile.DbDriver.Exec(sqlStatement)
			if err != nil {
				fmt.Fprintf(os.Stderr, "Error inserting new filesource relation for fileID = %d, typeID = %d, groupID = %d, fileName = %s: %v\n", fileID, fileType, sourceID, fileName, err)
			}
			return
		}

		found := false
		for _, foundFileName := range fileNames {
			if strings.Compare(foundFileName, fileName) == 0 {
				found = true
				break
			}
		}

		if !found {
			// First time seeing this file from this source with this file name
			fileNames = append(fileNames, fileName)
			_, err = context.ConfigFile.DbDriver.Exec("update filesource set filename = %s where fileid = %d and sourceid = %d", fileNames, fileID, sourceID)
			if err != nil {
				fmt.Fprintf(os.Stderr, "Error inserting new file name into existing filesource relation for fileID = %d, groupID = %d, fileName = %s: %v\n", fileID, sourceID, fileName, err)
			}
		}
		return
	}
}

func HashToPath(sha256Hash string) string {
	directoryDepth := utils.GetGlobalContext().ConfigFile.StoredSamplesDepth
	fPath := utils.GetGlobalContext().ConfigFile.StoredSamplesPath
	for i:= 0; i < directoryDepth*2; i+=2 {
		fPath += sha256Hash[i:i+2] + "/"
	}
	fPath += sha256Hash
	return fPath
}