package main

import (
	"crypto/rand"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"github.com/rjzak/MalwareDB/mdbcommon"
	"github.com/rjzak/MalwareDB/server/utils"
	"golang.org/x/crypto/bcrypt"
	"net/http"
	"strings"
)

func SetGetAPIKey(writer http.ResponseWriter, request *http.Request, config *utils.ServerConfigFile) {
	var err error
	jsonParser := json.NewDecoder(request.Body)
	apiKeyReq := mdbcommon.GetSetAPIKey{}
	jsonParser.Decode(&apiKeyReq)
	apiKeyReq.UserName = strings.TrimSpace(apiKeyReq.UserName)
	apiKeyReq.UserPassword = strings.TrimSpace(apiKeyReq.UserPassword)
	sql := fmt.Sprintf("select id, password from person where email = '%s'", apiKeyReq.UserName)
	hashedPasswordRow := config.DbDriver.QueryRow(sql)
	/*if err != nil {
		writer.Write([]byte("Error getting password from database"))
		fmt.Printf("Error getting password from DB for %s: %v.\n", apiKeyReq.UserName, err)
		return
	}*/
	var hashedPassword string = ""
	var userID int = -1
	//hashedPasswordRows.Next()
	err = hashedPasswordRow.Scan(&userID, &hashedPassword)
	if err != nil {
		writer.Write([]byte("Error getting password from database"))
		fmt.Printf("Error getting hashed password for user %s: %v.\n",apiKeyReq.UserName, err)
		return
	}
	passwordCheck := bcrypt.CompareHashAndPassword([]byte(hashedPassword), []byte(apiKeyReq.UserPassword))
	if passwordCheck != nil {
		writer.Write([]byte("Password Incorrect"))
		fmt.Printf("Failed login attempt for user %s from %s.\n", apiKeyReq.UserName, request.RemoteAddr)
		return
	}
	sql = fmt.Sprintf("select apikey from person where email = '%s'", apiKeyReq.UserName)
	apiKeyRow := config.DbDriver.QueryRow(sql)

	var apiKey string
	err = apiKeyRow.Scan(&apiKey)
	if err != nil {
		writer.Write([]byte("Error getting API Key from DB"))
		fmt.Printf("SQL error getting API Key for %s: %v.\n", apiKeyReq.UserName, err)
		return
	}

	if err == nil && len(apiKey) > 10 {
		apiKeyReq.APIKey = apiKey
		apiKeyReq.UserPassword = ""
		result, err := json.Marshal(apiKeyReq)
		if err != nil {
			writer.Write([]byte("Error creating JSON API Key response"))
			return
		}
		writer.Write([]byte(result))
		return
	} else {
		tempApiKeyBytes := make([]byte, 30)
		_, err := rand.Read(tempApiKeyBytes)
		encoded := base64.StdEncoding.EncodeToString([]byte(tempApiKeyBytes))
		sql := fmt.Sprintf("update person set apikey = '%s' where email = '%s' and id = %d", encoded, apiKeyReq.UserName, userID)
		_, err = config.DbDriver.Exec(sql)
		if err != nil {
			writer.Write([]byte("Error updating API Key in DB."))
			fmt.Printf("SQL error getting API Key for %s: %v.\n", apiKeyReq.UserName, err)
			return
		}
		apiKeyReq.APIKey = encoded
		apiKeyReq.UserPassword = ""
		result, err := json.Marshal(apiKeyReq)
		if err != nil {
			writer.Write([]byte("Error creating JSON API Key response"))
			return
		}
		writer.Write([]byte(result))
		fmt.Printf("Created new API key for user %s.\n", apiKeyReq.UserName)
		return
	}
}