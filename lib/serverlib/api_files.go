package serverlib

import (
	"database/sql"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"github.com/glaslos/ssdeep"
	"github.com/glaslos/tlsh"
	pg "github.com/lib/pq"
	"github.com/malwaredb/golzjd"
	"github.com/malwaredb/malwaredb/lib/mdbcommon"
	"github.com/malwaredb/malwaredb/lib/serverlib/utils"
	"net/http"
	"os"
	"strings"
)

func UploadFile(writer http.ResponseWriter, request *http.Request, config *utils.ServerConfigFile) {
	var err error
	jsonParser := json.NewDecoder(request.Body)
	uploadRequest := mdbcommon.NewSample{}
	err = jsonParser.Decode(&uploadRequest)
	if err != nil {
		writer.Write([]byte(mdbcommon.ERROR2))
		fmt.Printf("Error parsing upload struct: %v.\n", err)
		return
	}

	sql := fmt.Sprintf("select id from person where apikey = '%s'", uploadRequest.UserKey)
	apiKeyRow := config.DbDriver.QueryRow(sql)
	userID := -99
	err = apiKeyRow.Scan(&userID)
	if err != nil || userID < 0 {
		writer.Write([]byte("Error getting user ID from apikey"))
		fmt.Printf("SQL error getting User ID for API Key %s: %v.\n", uploadRequest.UserKey, err)
		return
	}

	fileBytes, err := base64.StdEncoding.DecodeString(uploadRequest.FileContentsBase64)
	if err != nil {
		writer.Write([]byte("Error processing file contents"))
		fmt.Printf("Unable to base64 decode uploaded sample: %v.\n", err)
		return
	}

	fileTypeID, err := FileTypeIDFromBytes(fileBytes, config)
	if err != nil || fileTypeID < 0 {
		writer.Write([]byte("File type not supported"))
		fmt.Printf("Rejected file from user %d for not being a supported file type.\n", userID)
		return
	}

	writer.Write([]byte(mdbcommon.ERROR0))
	go HandleFileSubmission(uploadRequest.FileName, fileBytes, fileTypeID, userID, uploadRequest.SourceID)
}

func FileSearch(writer http.ResponseWriter, request *http.Request) {
	serverConfig := utils.GetGlobalContext().ConfigFile
	jsonParser := json.NewDecoder(request.Body)
	searchRequest := mdbcommon.SearchSample{}
	err := jsonParser.Decode(&searchRequest)
	searchResponse := mdbcommon.SearchResult{}
	if err != nil {
		searchResponse.NumResults = -1
		searchResponse.Message = "Invalid request received."
		result, _ := json.Marshal(searchResponse)
		writer.Write(result)
		return
	}

	userID, err := ValidateUserAPIKey(searchRequest.APIKey)
	if userID < 0 || err != nil {
		searchResponse.NumResults = -1
		searchResponse.Message = "Invalid API key."
		result, _ := json.Marshal(searchResponse)
		writer.Write(result)
		return
	}

	if len(searchRequest.FileContentsBase64) > 10 {
		fileContents, err := base64.StdEncoding.DecodeString(searchRequest.FileContentsBase64)
		if err == nil {
			if len(searchRequest.SSDeep) < 10 {
				searchRequest.SSDeep, _ = ssdeep.FuzzyBytes(fileContents)
			}
			if len(searchRequest.TLSH) < 10 {
				tlshObj, err := tlsh.HashBytes(fileContents)
				if err == nil {
					searchRequest.TLSH = tlshObj.String()
				}
			}
			if len(searchRequest.LZJD) < 10 {
				searchRequest.LZJD = golzjd.GenerateHashFromBuffer(fileContents)
			}
		}
	}

	fileQuery := fmt.Sprintf("select distinct id, sha1, sha256, sha512, md5, lzjd, tlsh, ssdeep, sdhash, size, confirmedmalicious, entropy, createddate, filetypeid from file where sha1 = '%s' or md5 = '%s' or sha256 = '%s' or sha512 = '%s' ", searchRequest.SHA1, searchRequest.MD5, searchRequest.SHA256, searchRequest.SHA512)

	if searchRequest.SimilarityThreshold > 0.0 {
		if serverConfig.LZJDQueryAvailable() {
			fileQuery += fmt.Sprintf(" or lzjd_compare('%s', lzjd) > %f", searchRequest.LZJD, searchRequest.SimilarityThreshold)
		}

		if serverConfig.SSDeepQueryAvailable() {
			fileQuery += fmt.Sprintf(" or fuzzy_hash_compare('%s', ssdeep) > %f", searchRequest.SSDeep, searchRequest.SimilarityThreshold)
		}

		if len(searchRequest.SDHash) > 10 && serverConfig.SDHashQueryAvailable() {
			fileQuery += fmt.Sprintf(" or sdhash_compare('%s', sdhash) > %f", searchRequest.SDHash, searchRequest.SimilarityThreshold)
		}

		if len(searchRequest.TLSH) > 10 && serverConfig.TLSHQueryAvailable() {
			fileQuery += fmt.Sprintf(" or tlsh_compare('%s', tlsh) > %f", searchRequest.TLSH, searchRequest.SimilarityThreshold)
		}
	}
	fmt.Println(searchRequest)

	rows, err := serverConfig.DbDriver.Query(fileQuery)
	if err != nil {
		searchResponse.NumResults = -1
		searchResponse.Message = err.Error()
		result, _ := json.Marshal(searchResponse)
		writer.Write(result)
		return
	}

	defer rows.Close()
	for rows.Next() {
		var sampleInfo mdbcommon.SampleInfo
		var tlshString sql.NullString
		sampleInfo.FileExecutable = false
		var confirmedBad sql.NullBool
		var fileTypeID int
		err = rows.Scan(&sampleInfo.ID, &sampleInfo.SHA1, &sampleInfo.SHA256, &sampleInfo.SHA512, &sampleInfo.MD5, &sampleInfo.LZJD, &tlshString,
			&sampleInfo.SSDeep, &sampleInfo.SDHash, &sampleInfo.Size, &confirmedBad, &sampleInfo.Entropy, &sampleInfo.FirstUploadDate, &fileTypeID)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Error getting row %s.\n", err)
			continue
		}
		if tlshString.Valid {
			sampleInfo.TLSH = tlshString.String
		}
		fTypeQuery := fmt.Sprintf("select name, executable from filetype where id = %d", fileTypeID)
		typeRow := serverConfig.DbDriver.QueryRow(fTypeQuery)
		if typeRow == nil {
			var isExecutable sql.NullBool
			typeRow.Scan(&sampleInfo.FileType, &isExecutable)
			if isExecutable.Valid && isExecutable.Bool {
				sampleInfo.FileExecutable = true
			}
		}
		sampleInfo.SimilarityScore = -1
		if len(searchRequest.SHA512) == 128 && strings.ToUpper(searchRequest.SHA512) == strings.ToUpper(sampleInfo.SHA512) {
			sampleInfo.SimilarityScore = 100
		} else {
			if len(searchRequest.SHA256) == 64 && strings.ToUpper(searchRequest.SHA256) == strings.ToUpper(sampleInfo.SHA256) {
				sampleInfo.SimilarityScore = 100
			} else {
				if len(searchRequest.SHA1) == 40 && strings.ToUpper(searchRequest.SHA1) == strings.ToUpper(sampleInfo.SHA1) {
					sampleInfo.SimilarityScore = 100
				}
				if len(searchRequest.LZJD) > 10 && len(sampleInfo.LZJD) > 10 {
					sampleInfo.SimilarityScore = float64(golzjd.CompareHashes(searchRequest.LZJD, sampleInfo.LZJD))
				} else {
					if len(searchRequest.SSDeep) > 10 && len(sampleInfo.SSDeep) > 10 {
						ssdeepScore, err := ssdeep.Distance(searchRequest.SSDeep, sampleInfo.SSDeep)
						if err == nil {
							sampleInfo.SimilarityScore = float64(ssdeepScore)
						}
					}
				}
			}
		}

		if searchRequest.SendSample {
			fmt.Printf("Send file requested.\n")
			fileContents, err := HashToBytes(sampleInfo.SHA256)
			if err != nil {
				fmt.Fprintf(os.Stderr, "Can't find file for hash %s: %s.\n", sampleInfo.SHA256, err)
			} else {
				sampleInfo.FileContentsBase64 = base64.StdEncoding.EncodeToString(fileContents)
			}
		}

		sourceInfoQuery := fmt.Sprintf("select filesource.filename, source.name, source.id, person.uname from filesource join source on (filesource.sourceid = source.id) join person on (filesource.userid = person.id) where filesource.fileid = %d", sampleInfo.ID)
		sourceRows, err := serverConfig.DbDriver.Query(sourceInfoQuery)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Error getting source information for file ID %d: %s\n", sampleInfo.ID, err)
		} else {
			for sourceRows.Next() {
				var sampleSource mdbcommon.SampleSource
				var fileNames pg.StringArray
				err = sourceRows.Scan(&fileNames, &sampleSource.SourceName, &sampleSource.SourceID, &sampleSource.UploaderUname)
				if err != nil {
					fmt.Fprintf(os.Stderr, "Error getting source information for file ID %d: %s\n", sampleInfo.ID, err)
				}
				sampleInfo.Sources = append(sampleInfo.Sources, sampleSource)
			}
		}
		searchResponse.NumResults += 1
		searchResponse.FoundSamples = append(searchResponse.FoundSamples, sampleInfo)
	}

	result, _ := json.Marshal(searchResponse)
	writer.Write(result)
}