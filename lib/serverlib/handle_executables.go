package serverlib

import (
	"bytes"
	"debug/elf"
	"debug/macho"
	"debug/pe"
	"fmt"
	pg "github.com/lib/pq"
	"github.com/malwaredb/malwaredb/lib/serverlib/utils"
	"os"
	"github.com/malwaredb/imphash"
)

func HandleExecutable(fileContents []byte, fileID int64, fileTypeID int) {
	serverContext := utils.GetGlobalContext()
	dbConn := serverContext.ConfigFile.DbDriver
	typeInfoQuery := dbConn.QueryRow("select name, executable from filetype where id = $1", fileTypeID)
	typeName := ""
	isExec := false
	err := typeInfoQuery.Scan(&typeName, &isExec)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error getting information for file type id %d: %s\n", fileTypeID, err)
		return
	}
	if !isExec {
		return
	}

	alreadyEvaledQuery := dbConn.QueryRow("select count(1) from executable where fileid = $1", fileID)
	numRows := -1
	alreadyEvaledQuery.Scan(&numRows)
	if numRows > 0 {
		fmt.Printf("File ID %d already in executable table.\n", fileID)
		return
	}

	byteReader := bytes.NewReader(fileContents)
	numSections := 0
	var sectionNames pg.StringArray
	var sectionEntropies pg.Float64Array

	if typeName == "PE32" {
		peFile, err := pe.NewFile(byteReader)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Error parsing PE32 file %d: %s.\n", fileID, err)
			return
		}
		defer peFile.Close()
		numSections = len(peFile.Sections)
		for _, thisSection := range peFile.Sections {
			sectionNames = append(sectionNames, thisSection.Name)
			sectionBytes, err := thisSection.Data()
			sectionEntropy := -1.0
			if err == nil {
				sectionEntropy = Entropy(sectionBytes)
				sectionEntropies = append(sectionEntropies, sectionEntropy)
			}
		}
	}

	if typeName == "ELF" {
		elfFile, err := elf.NewFile(byteReader)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Error parsing ELF file %d: %s.\n", fileID, err)
			return
		}
		defer elfFile.Close()
		numSections = len(elfFile.Sections)
		for _, thisSection := range elfFile.Sections {
			sectionNames = append(sectionNames, thisSection.Name)
			sectionBytes, err := thisSection.Data()
			sectionEntropy := -1.0
			if err == nil {
				sectionEntropy = Entropy(sectionBytes)
				sectionEntropies = append(sectionEntropies, sectionEntropy)
			}
		}
	}

	if typeName == "Mach-O" {
		machFile, err := macho.NewFile(byteReader)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Error parsing Mach-O file %d: %s.\n", fileID, err)
			return
		}
		defer machFile.Close()
		numSections = len(machFile.Sections)
		for _, thisSection := range machFile.Sections {
			sectionNames = append(sectionNames, thisSection.Name)
			sectionBytes, err := thisSection.Data()
			sectionEntropy := -1.0
			if err == nil {
				sectionEntropy = Entropy(sectionBytes)
				sectionEntropies = append(sectionEntropies, sectionEntropy)
			}
		}
	}

	importHashStr := ""
	importHashFuzzyStr := ""
	importHashes, err := imphash.ImpHashFromBytes(fileContents)
	if err == nil {
		importHashStr = importHashes.ImpHash
		importHashFuzzyStr = importHashes.ImpFuzzy
	}
	if numSections > 0 {
		// If the section parsing failed, I doubt Go was successful getting imports data
		_, err = dbConn.Exec("insert into executable(fileid, sections, sectionnames, sectionentropies, importhash, importhashfuzzy) values($1, $2, $3, $4, $5, $6)", fileID, numSections, sectionNames, sectionEntropies, importHashStr, importHashFuzzyStr)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Error inserting into executables table for file %d: %s\n", fileID, err)
		}
	}
}