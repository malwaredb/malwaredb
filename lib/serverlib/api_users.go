package serverlib

import (
	"crypto/rand"
	"encoding/base64"
	"encoding/json"
	"database/sql"
	"errors"
	"fmt"
	"github.com/malwaredb/malwaredb/lib/mdbcommon"
	"github.com/malwaredb/malwaredb/lib/serverlib/utils"
	"golang.org/x/crypto/bcrypt"
	"net/http"
	"os"
	"strings"
)

func SetGetAPIKey(writer http.ResponseWriter, request *http.Request, config *utils.ServerConfigFile) {
	jsonParser := json.NewDecoder(request.Body)
	apiKeyReq := mdbcommon.GetSetAPIKey{}
	jsonParser.Decode(&apiKeyReq)
	apiKeyReq.UserName = strings.TrimSpace(apiKeyReq.UserName)
	apiKeyReq.UserPassword = strings.TrimSpace(apiKeyReq.UserPassword)
	field := "uname"
	if strings.Contains(apiKeyReq.UserName, "@") {
		field = "email"
	}

	sqlStatement := fmt.Sprintf("select id, password from person where %s = '%s'", field, apiKeyReq.UserName)
	hashedPasswordRow := config.DbDriver.QueryRow(sqlStatement)

	var hashedPassword string = ""
	var userID int = -1
	err := hashedPasswordRow.Scan(&userID, &hashedPassword)
	if err == sql.ErrNoRows {
		apiKeyReq.Message = fmt.Sprintf("User %s not found", apiKeyReq.UserName)
		apiKeyReq.UserPassword = ""
		result, _ := json.Marshal(apiKeyReq)
		writer.Write(result)
		fmt.Fprintf(os.Stderr, "No rows returned for user %s.\n", apiKeyReq.UserName)
		return
	}
	if err != nil {
		apiKeyReq.Message = "Error getting password from database"
		apiKeyReq.UserPassword = ""
		result, _ := json.Marshal(apiKeyReq)
		writer.Write(result)
		fmt.Printf("Error getting hashed password for user %s: %v.\n",apiKeyReq.UserName, err)
		return
	}
	passwordCheck := bcrypt.CompareHashAndPassword([]byte(hashedPassword), []byte(apiKeyReq.UserPassword))
	if passwordCheck != nil {
		apiKeyReq.UserPassword = ""
		apiKeyReq.Message = "Password incorrect"
		result, _ := json.Marshal(apiKeyReq)
		writer.Write(result)
		fmt.Printf("Failed login attempt for user %s from %s.\n", apiKeyReq.UserName, request.RemoteAddr)
		return
	}
	sqlStatement = fmt.Sprintf("select apikey from person where %s = '%s'", field, apiKeyReq.UserName)
	apiKeyRow := config.DbDriver.QueryRow(sqlStatement)

	var apiKey sql.NullString
	err = apiKeyRow.Scan(&apiKey)
	if err != nil {
		writer.Write([]byte("Error getting API Key from DB"))
		fmt.Printf("SQL error getting API Key for %s: %v.\n", apiKeyReq.UserName, err)
		return
	}

	if apiKey.Valid {
		apiKeyReq.APIKey = apiKey.String
		apiKeyReq.UserPassword = ""
		apiKeyReq.Message = "Success"
		result, _ := json.Marshal(apiKeyReq)
		writer.Write(result)
		return
	} else {
		tempApiKeyBytes := make([]byte, 30)
		_, err := rand.Read(tempApiKeyBytes)
		encoded := base64.StdEncoding.EncodeToString(tempApiKeyBytes)
		sql := fmt.Sprintf("update person set apikey = '%s' where id = %d", encoded, userID)
		_, err = config.DbDriver.Exec(sql)
		if err != nil {
			apiKeyReq.UserPassword = ""
			apiKeyReq.Message = "Database error"
			result, _ := json.Marshal(apiKeyReq)
			writer.Write(result)
			fmt.Printf("SQL error getting API Key for %s: %v.\n", apiKeyReq.UserName, err)
			return
		}
		apiKeyReq.APIKey = encoded
		apiKeyReq.UserPassword = ""
		apiKeyReq.Message = "Success"
		result, _ := json.Marshal(apiKeyReq)
		writer.Write(result)
		fmt.Printf("Created new API key for user %s.\n", apiKeyReq.UserName)
		return
	}
}

func GetSelfInfo(writer http.ResponseWriter, request *http.Request, config *utils.ServerConfigFile) {
	jsonParser := json.NewDecoder(request.Body)
	minimalRequest := mdbcommon.MinimalRequest{}
	jsonParser.Decode(&minimalRequest)
	uid, err := ValidateUserAPIKey(minimalRequest.APIKey)
	if err != nil {
		errResponse := mdbcommon.MinimalResponse {
			Message: mdbcommon.ERROR1,
		}
		result, _ := json.Marshal(errResponse)
		writer.Write(result)
		return
	}

	row := config.DbDriver.QueryRow("select email, uname, firstname, lastname, organisation, phone, created from person where id = $1", uid)
	if row == nil {
		errResponse := mdbcommon.MinimalResponse {
			Message: mdbcommon.ERROR3,
		}
		result, _ := json.Marshal(errResponse)
		writer.Write(result)
		return
	}

	userSelfInfo := mdbcommon.GetSelfInfo{}
	orgNullable := sql.NullString{}
	phoneNullable := sql.NullString{}
	err = row.Scan(&userSelfInfo.Email, &userSelfInfo.Username, &userSelfInfo.Fname, &userSelfInfo.Lname, &orgNullable, &phoneNullable, &userSelfInfo.Created)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error getting user info: %s\n", err)
	}

	if orgNullable.Valid {
		userSelfInfo.Org = orgNullable.String
	}

	if phoneNullable.Valid {
		userSelfInfo.Phone = phoneNullable.String
	}

	resultResponse, _ := json.Marshal(userSelfInfo)
	writer.Write(resultResponse)
}

func ValidateUserAPIKey(apiKey string) (int, error) {
	dbConn := utils.GetGlobalContext().ConfigFile.DbDriver
	sqlValidateUser := fmt.Sprintf("select id from person where apikey = '%s'", apiKey)
	userID := -1
	queryRow := dbConn.QueryRow(sqlValidateUser)
	err := queryRow.Scan(&userID)
	if err == sql.ErrNoRows {
		return -1, errors.New("Invalid API Key")
	}
	return userID, err
}