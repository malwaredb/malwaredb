package serverlib

import (
	"database/sql"
	"errors"
	"fmt"
	"bytes"
	"github.com/glaslos/ssdeep"
	"github.com/malwaredb/golzjd"
	"github.com/malwaredb/gosdhash"
	"github.com/malwaredb/malwaredb/lib/mdbcommon"
	"github.com/malwaredb/malwaredb/lib/serverlib/utils"
	"io/ioutil"
	"os"
	"path/filepath"
	"strings"
	pg "github.com/lib/pq"
	"github.com/glaslos/tlsh"
)

func FileTypeIDFromBytes(fileContents []byte, config *utils.ServerConfigFile) (int, error) {
	rows, err := config.DbDriver.Query("select id, magic, name from filetype")
	if err != nil {
		return -1, err
	}

	var fileTypeID int = -1
	var fileTypeName = ""
	var magic pg.ByteaArray
	var matched = false
	for rows.Next() {
		err = rows.Scan(&fileTypeID, &magic, &fileTypeName)
		if err != nil {
			rows.Close()
			return -1, err
		}

		for _, magicNum := range magic {
			//fmt.Printf("Testing: %v : %s.\n", magicNum, fileTypeName)
			if bytes.HasPrefix(fileContents, magicNum) {
				matched = true
				break
			}
		}
		if matched {
			break
		}
	}
	rows.Close()
	if matched {
		return fileTypeID, nil
	}
	return -1, nil
}

func HandleFileSubmission(fileName string, fileContents []byte, fileType int, userID int, sourceID int64) {
	var err error
	context := utils.GetGlobalContext()
	context.GlobalWaitGroup.Add(1)
	defer context.GlobalWaitGroup.Done()

	fileHashes := mdbcommon.GetFileHashesFromBytes(fileContents)
	// Similarity hashes are calculated on the server-side due to cross-platform compilation issues
	// It would be nice to have these hashes rewritten in Go.
	if len(fileHashes.SSDeep) < 2 {
		fileHashes.SSDeep, _ = ssdeep.FuzzyBytes(fileContents)
	}

	if len(fileHashes.LZJD) < 2 {
		fileHashes.LZJD = golzjd.GenerateHashFromBuffer(fileContents)
	}

	if len(fileHashes.SDHash) < 2 {
		fileHashes.SDHash = strings.TrimSpace(sdhash.SDHash_From_Buffer(fileName, fileContents))
	}

	if len(fileHashes.TLSH) < 2 {
		tlshTmp, _ := tlsh.HashBytes(fileContents)
		fileHashes.TLSH = tlshTmp.String()
	}

	sqlStatement := fmt.Sprintf("select id from file where sha256 = '%s'", fileHashes.SHA256)
	row := context.ConfigFile.DbDriver.QueryRow(sqlStatement)

	fileID := int64(-9)
	err = row.Scan(&fileID)

	if err == sql.ErrNoRows {
		// Add this new file to the database
		//fmt.Println("File not seen previously, inserting into DB")
		fileEntropy := Entropy(fileContents)
		sqlStatement = fmt.Sprintf("insert into file(sha1, sha256, sha512, md5, lzjd, ssdeep, sdhash, tlsh, filetypeid, size, entropy) values ('%s', '%s', '%s', '%s', '%s', '%s', '%s', '%s', %d, %d, %f)", fileHashes.SHA1, fileHashes.SHA256, fileHashes.SHA512, fileHashes.MD5, fileHashes.LZJD, fileHashes.SSDeep, fileHashes.SDHash, fileHashes.TLSH, fileType, len(fileContents), fileEntropy)
		_, err = context.ConfigFile.DbDriver.Exec(sqlStatement)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Failed to insert new file record: %v\n", err)
			fmt.Fprintf(os.Stderr, "SQL: %s\n", sqlStatement)
			return
		}
		//fmt.Println("File inserted into file table.")
		sqlStatement = fmt.Sprintf("select id from file where sha256 = '%s'", fileHashes.SHA256)
		row = context.ConfigFile.DbDriver.QueryRow(sqlStatement)
		if row.Scan(&fileID) == sql.ErrNoRows {
			fmt.Fprintf(os.Stderr, "Failed to get file id from newly-inserted new file record: %v\n", err)
			return
		}
		//fmt.Printf("File has an ID: %d\n", fileID)
		sqlStatement = fmt.Sprintf("insert into filesource(fileid, sourceid, userid, filename, firstseen) values(%d, %d, %d, ARRAY['%s'], CURRENT_TIMESTAMP)", fileID, sourceID, userID, fileName)
		_, err = context.ConfigFile.DbDriver.Exec(sqlStatement)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Failed to set relationship between fileid %d and sourceid %d for newly-uploaded file: %v\n", fileID, sourceID, err)
			fmt.Fprintf(os.Stderr, "SQL: %s\n", sqlStatement)
		}
		fPath := HashToPath(fileHashes.SHA256)
		fileObj, err := os.Create(fPath)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Error creating file %s: %s.\n", fPath, err)
		} else {
			_, err = fileObj.Write(fileContents)
			if err != nil {
				fmt.Fprintf(os.Stderr, "Failed to write file to disk: %s.", err)
			}
			fileObj.Close()
		}
		for _, mdbPlugin := range context.FileTypePlugins {
			if bytes.Equal(fileContents[:len(mdbPlugin.FileTypeMagic())], mdbPlugin.FileTypeMagic()) {
				err = mdbPlugin.ProcessFile(fileContents, fileType, context)
				if err != nil {
					fmt.Fprintf(os.Stderr, "Error running plugin %s: %s.\n", mdbPlugin.FileTypeName(), err)
				}
			}
		}
		HandleExecutable(fileContents, fileID, fileType)
	} else {
		var fileNames pg.StringArray
		// File has already been seen
		sqlStatement = fmt.Sprintf("select filename from filesource where fileid = %d and sourceid = %d", fileID, sourceID)
		row := context.ConfigFile.DbDriver.QueryRow(sqlStatement)
		if row.Scan(&fileNames) == sql.ErrNoRows {
			// First time seeing this file from this source
			sqlStatement = fmt.Sprintf("insert into filsource(fileid, sourceid, filename, firstseen) values(%d, %d, {'%s'}, CURRENT_TIMESTAMP", fileID, sourceID, fileName)
			_, err = context.ConfigFile.DbDriver.Exec(sqlStatement)
			if err != nil {
				fmt.Fprintf(os.Stderr, "Error inserting new filesource relation for fileID = %d, typeID = %d, groupID = %d, fileName = %s: %v\n", fileID, fileType, sourceID, fileName, err)
			}
			return
		}

		found := false
		for _, foundFileName := range fileNames {
			if strings.ToLower(foundFileName) == strings.ToLower(fileName) {
				found = true
				break
			}
		}

		if !found {
			// First time seeing this file from this source with this file name
			fileNames = append(fileNames, fileName)
			_, err = context.ConfigFile.DbDriver.Exec("update filesource set filename = $1 where fileid = $2 and sourceid = $3", fileNames, fileID, sourceID)
			if err != nil {
				fmt.Fprintf(os.Stderr, "Error inserting new file name into existing filesource relation for fileID = %d, groupID = %d, fileName = %s: %v\n", fileID, sourceID, fileName, err)
			}
		}
		return
	}
}

func HashToPath(sha256Hash string) string {
	directoryDepth := utils.GetGlobalContext().ConfigFile.StoredSamplesDepth
	fPath := utils.GetGlobalContext().ConfigFile.StoredSamplesPath
	//fmt.Printf("Sample directory depth: %d\n", directoryDepth)
	for i:= 0; i < directoryDepth*2; i+=2 {
		fPath = filepath.Join(fPath, sha256Hash[i:i+2])
	}
	if !mdbcommon.Exists(fPath) {
		if err := os.MkdirAll(fPath, 1770); err != nil {
			fmt.Fprintf(os.Stderr, "Failed to make destination directory for malware sample: %s.\n", err)
		}
	}
	fPath = filepath.Join(fPath, sha256Hash)
	return fPath
}

func HashToBytes(sha256Hash string) ([]byte, error) {
	fPath := utils.GetGlobalContext().ConfigFile.StoredSamplesPath
	counter := -2
	for {
		counter += 2
		testPath := fPath + "/" + sha256Hash
		//fmt.Printf("Testing file %s\n", testPath)
		if mdbcommon.Exists(testPath) {
			return ioutil.ReadFile(testPath)
		}
		if counter >= len(sha256Hash) {
			break
		}
		testPath = fPath + "/" + sha256Hash[counter:counter+2]
		//fmt.Printf("Testing dir %s\n", testPath)
		if mdbcommon.Exists(testPath) {
			fPath = testPath
			continue
		}
		break
	}
	return make([]byte, 0), errors.New("hash not found")
}
