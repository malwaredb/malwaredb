package mdbcommon

import (
	"time"
)

const ERROR0 = "OK" // No errors
const ERROR1 = "Unauthorized"
const ERROR2 = "Invalid Request"
const ERROR3 = "Not Found"
const ERROR4 = "Server Error"

type MinimalRequest struct {
	APIKey string `json:"APIKey"`
}

type MinimalResponse struct {
	Message string `json:"message"`
}


// Request, Response same struct. Respond with password empty.
const UserLoginURL string = "/v1/users/getkey"
type GetSetAPIKey struct {
	UserName string `json:"username"`
	UserPassword string `json:"userpassword"`
	APIKey string `json:"apikey"`
	Message string `json:"message"`
}

// Request empty, respond with struct.
const GetServerInfoURL string = "/v1/server/info"
type ServerInfo struct {
	OSName string `json:"OSName"`
	OSVersion string `json:"OSVersion"`
	GoVersion string `json:"GoVersion"`
	MDBVersion string `json:"MDBVersion"`
	DBVersion string `json:"DBVersion"`
	NumSamples int `json:"NumSamples"`
	Uptime string `json:"Uptime"`
}

// Get supported file types, useful for clients
const GetServerSupportedFileTypes string = "/v1/server/types"
type FileType struct {
	TypeName string `json:"TypeName"`
	TypeMagic []string `json:"TypeMagicArray"`
	TypeExecutable bool `json:"TypeExecutable"`
	Description string `json:"TypeDescription"`
}
type ServerFileTypes struct {
	NumFileTypes int `json:"NumFileTypes"`
	FileTypes []FileType `json:"FileTypes"`
}

// Request with GetSourcesRequest, respond with Sources.
const GetFileSources string = "/v1/sources/list"
type SourceInfo struct {
	Id int64 `json:"SourceID"`
	Name string `json:"SourceName"`
	Description string `json:"SourceDescription"`
	URL string `json:"SourceURL"`
	FirstAcquisition time.Time `json:"SourceAcquisition"`
	IsReleasable bool `json:"SourceReleasable"`
}
type Sources struct {
	NumSources int `json:"NumSources"`
	Sources []SourceInfo `json:"Sources"`
	ResponseMessage string `json:"SourceResponseMessage"`
}
type GetSourcesRequest struct {
	ReleasableOnly bool `json:"OnlyReleasable"`
	APIKey string `json:"APIKey"`
}

// Request with struct, respond with error code.
const UploadSampleURL string = "/v1/samples/upload"
type NewSample struct {
	FileName string `json:"FileName"`
	UserKey string `json:"APIKey"`
	SourceID int64 `json:"GroupID"`
	FileContentsBase64 string `json:"FileContentsB64"`
}

// Request with SearchSample, respond with SampleInfo or error code.
const SearchBySampleInfoURL string = "/v1/samples/search"
type SearchSample struct {
	SHA1 string `json:"SHA1"`
	SHA256 string `json:"SHA256"`
	SHA512 string `json:"SHA512"`
	MD5 string `json:"MD5"`
	SSDeep string `json:"SSDeep"`
	SDHash string `json:"SDHash"`
	LZJD string `json:"LZJD"`
	TLSH string `json:"tlsh"`
	FileContentsBase64 string `json:"FileContentsB64"`
	SimilarityThreshold float64 `json:"SimilarityThreshold"` // For SSDeep, SDHash, LZJD.
	SendSample bool `json:"SendSample"`
	APIKey string `json:"APIKey"`
}

// Sample might be in multiple sources
type SampleSource struct {
	SourceName string `json:"SourceName"`
	SourceID int64 `json:"SourceID"`
	FileNames []string `json:"FileNames"`
	UploaderUname string `json:"UploaderUname"`
}

type SampleInfo struct {
	ID int64 `json:"ID"`
	Size int `json:"Size"`
	SHA1 string `json:"SHA1"`
	SHA256 string `json:"SHA256"`
	SHA512 string `json:"SHA512"`
	MD5 string `json:"MD5"`
	SSDeep string `json:"SSDeep"`
	SDHash string `json:"SDHash"`
	LZJD string `json:"LZJD"`
	TLSH string `json:"TLSH"`
	SimilarityScore float64 `json:"SimilarityScore"`
	FirstUploadDate string `json:"FirstUploadDate"`
	FileCreatedDate string `json:"FileCreatedDate"`
	Entropy float64 `json:"Entropy"`
	ConfirmedMalicious bool `json:"ConfirmedMalicious"`
	FileType string `json:"FileType"`
	FileExecutable bool `json:"FileExecutable"`
	Labels []string `json:"Labels"`
	FileContentsBase64 string `json:"FileContentsB64"`
	Sources []SampleSource `json:"SampleSources"`
}

type SearchResult struct {
	NumResults int `json:"NumResults"`
	FoundSamples []SampleInfo `json:"FoundSamples"`
	Message string `json:"Message"`
}

const UserGetSelfInfoURL = "/v1/self"
type GetSelfInfo struct {
	MinimalResponse
	UserID int32 `json:"UID"`
	Email string `json:"email"`
	Username string `json:"username"`
	Fname string `json:"fname"`
	Lname string `json:"lname"`
	Org string `json:"org"`
	Phone string `json:"phone"`
	Created string `json:"created"`
}

// Administrative functionality
// All usage requires user ID = 0, or membership in group with ID = 0
const AdminListUsers string = "/v1/admin/users/list"

const AddUser string = "/v1/admin/users/create"
const EditUser string = "/v1/admin/users/edit"
type AdminAddEditUser struct {
	MinimalRequest
	UserID int32 `json:"UID"`
	Email string `json:"email"`
	Username string `json:"username"`
	Fname string `json:"fname"`
	Lname string `json:"lname"`
	Org string `json:"org"`
	Phone string `json:"phone"`
	Password string `json:"password"` // Only for setting passwords
}

const SearchUser string = "/v1/admin/users/search"
type AdminSearchUsers struct {
	MinimalRequest
	UserID int32 `json:"UID"`
	Email string `json:"email"`
	Username string `json:"username"`
	Fname string `json:"fname"`
	Lname string `json:"lname"`
	Org string `json:"org"`
	Phone string `json:"phone"`
	HasAPIkey bool `json:"hasKey"`
}

type AdminUserInformation struct { // For users list, search
	UserID int32 `json:"UID"`
	Email string `json:"email"`
	Username string `json:"username"`
	Fname string `json:"fname"`
	Lname string `json:"lname"`
	Org string `json:"org"`
	Phone string `json:"phone"`
	Created time.Time `json:"created"`
	HasAPIkey bool `json:"hasKey"`
	IsAdmin bool `json:"isAdmin"`
}

type AdminSearchUsersResult struct { // For users list, search
	MinimalResponse
	NumResults int `json:"numResults"`
	FoundUsers []AdminUserInformation `json:"results"`
}

const ToggleUserActive string = "/v1/admin/users/toggle"
type AdminToggleUser struct {
	MinimalRequest
	UserID int32 `json:"UID"`
	SetActive bool `json:"isActive"`
}

