package mdbcommon

import (
	"crypto/md5"
	"crypto/sha256"
	"crypto/sha512"
	"fmt"
	"crypto/sha1"
	"github.com/glaslos/ssdeep"
	"github.com/malwaredb/golzjd"
	"golang.org/x/crypto/bcrypt"
	"io/ioutil"
	"os"
)

const VERSION string = "0.0.0"
const WEBSITE string = "https://github.com/rjzak/malwaredb"

type FileHashes struct {
	SHA1 string
	SHA256 string
	SHA512 string
	MD5 string
	LZJD string
	SSDeep string
	SDHash string
}

func GetFileHashesFromBytes(fileContents []byte) FileHashes {
	var fileHashes FileHashes
	fileHashes.SHA1 = fmt.Sprintf("%X", sha1.Sum(fileContents))
	fileHashes.SHA256 = fmt.Sprintf("%X", sha256.Sum256(fileContents))
	fileHashes.SHA512 = fmt.Sprintf("%X", sha512.Sum512(fileContents))
	fileHashes.MD5 = fmt.Sprintf("%X", md5.Sum(fileContents))
	fileHashes.LZJD = golzjd.GenerateHashFromBuffer(fileContents)
	fileHashes.SSDeep, _ = ssdeep.FuzzyBytes(fileContents)

	return fileHashes
}

func (hashes *FileHashes) GetSearchQuery() SearchSample {
	var searchQuery SearchSample
	searchQuery.MD5 = hashes.MD5
	searchQuery.SHA1 = hashes.SHA1
	searchQuery.SHA256 = hashes.SHA256
	searchQuery.SHA512 = hashes.SHA512
	searchQuery.LZJD = hashes.LZJD
	searchQuery.SSDeep = hashes.SSDeep
	searchQuery.SendSample = false
	return searchQuery
}

func GetFileHashesFromFilePath(fPath string) (*FileHashes, error) {
	fileContents, err := ioutil.ReadFile(fPath)
	if err != nil {
		return nil, err
	}
	fileHashes := GetFileHashesFromBytes(fileContents)
	return &fileHashes, nil
}

func Exists(path string) bool {
	_, err := os.Stat(path)
	if err == nil { return true }
	if os.IsNotExist(err) { return false }
	return true
}

func PasswordToBytes(password []byte) ([]byte, error) {
	return bcrypt.GenerateFromPassword(password, bcrypt.DefaultCost)
}