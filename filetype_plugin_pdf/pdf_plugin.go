package main

import (
	"bytes"
	"github.com/rjzak/MalwareDB/filetype_plugin_base"
	"github.com/rjzak/MalwareDB/server/utils"
	"fmt"
	"database/sql"
	"github.com/pdfcpu/pdfcpu/pkg/pdfcpu"
)

type PDFPlugin struct {

}

func (pdfp *PDFPlugin) FileTypeName() string {
	return "PDF"
}

func (pdfp *PDFPlugin) FileTypeMagic() []byte {
	return []byte{0x25, 0x50, 0x44, 0x46} // %PDF
}

func (pdfp* PDFPlugin) DBTableName() string {
	return "PDF"
}

func (pdfp* PDFPlugin) ProcessFile(fileContents []byte, fileID int, ServerContext *utils.ServerContext) error {
	var err error
	databaseConnection := ServerContext.ConfigFile.DbDriver

	sqlStatement := fmt.Sprintf("select pages, streams from pdf where fileid = %d", fileID)
	row := databaseConnection.QueryRow(sqlStatement)
	var streams, pages int = -1, -1
	err = row.Scan(&pages, &streams)
	if err == sql.ErrNoRows {
		pdfBytes := bytes.NewReader(fileContents)
		pdfConfig := pdfcpu.NewDefaultConfiguration()
		pdfConfig.CollectStats = true
		pdfContext, err := pdfcpu.Read(pdfBytes, pdfConfig)
		if err != nil {
			return err
		}
		numPages := pdfContext.PageCount
		numStreams := len(pdfContext.Read.ObjectStreams)
		sqlStatement = fmt.Sprintf("insert into pdf(fileid, pages, streams) values(%d, %d, %d", fileID, numPages, numStreams)
		_, err = databaseConnection.Exec(sqlStatement)

	}

	return err
}

func New() filetype_plugin_base.FileTypeHandler {
	return new(PDFPlugin)
}